Spiegazione dettagliata di recursive1.py (versione aggiornata)
==============================================================

File di riferimento
-------------------
/Users/emanuelelippi/Library/Mobile Documents/com~apple~CloudDocs/Universita/Tirocinio/code/FBSDENN_Lippi/recursive/recursive1.py

Questa nota descrive la versione corrente del codice, inclusi:
- pipeline ricorsiva generalizzata a N passate (`--passes`),
- resume da run precedente (`--resume_models_dir`, `--resume_from_pass`),
- salvataggio completo degli artefatti (config, metriche, modelli, stitched predictions),
- plotting multi-pass (loss/y0 per blocco e convergenza su Y stitched),
- piano di training configurabile via CSV.


Obiettivo generale
------------------
Lo script supporta due modalita:
1) standard: training classico su singolo intervallo temporale.
2) recursive: time-stitching a blocchi per orizzonti lunghi (es. T=48).

Idea del ricorsivo:
- dividere [0, T_totale] in blocchi [t_i, t_{i+1}],
- allenare backward dall'ultimo blocco al primo,
- usare la rete del blocco successivo come condizione terminale del blocco corrente,
- ripetere il processo per piu passate, aggiornando i generatori empirici a ogni pass.


Struttura del codice
--------------------
1) FBSNN (classe madre)
- struttura compatibile con la base:
  - Xi_generator, placeholders, loss BSDE, Adam, clipping, evaluate/predict.
- funzioni importanti:
  - save_model(path) / load_model(path) per checkpoint TF (.ckpt).

2) NN_Quadratic_Coupled (prima figlia)
- mantiene mu_tf, phi_tf, g_tf, sigma_tf della formulazione quadratica 4D.

3) NN_Quadratic_Coupled_Recursive (estensione)
- aggiunge:
  - tempi assoluti di blocco (t_start, t_end),
  - normalizzazione input tempo/stato,
  - terminal stitching da blob del blocco successivo,
  - export/import pesi in NPZ:
    - export_parameter_blob()
    - import_parameter_blob(...)
    - save_parameter_blob(path)
    - load_parameter_blob(path)


Funzionalita principali aggiunte
--------------------------------

1) Passate ricorsive generalizzate (`--passes`)
- prima: pipeline fissa pass1 -> pass2.
- ora: pipeline parametrica pass1 -> pass2 -> ... -> passN.
- `pass_scope` nel CSV (es. `2+`) viene applicato a tutte le passate >= 2.

2) Resume da run precedente
- nuove opzioni:
  - `--resume_models_dir`
  - `--resume_from_pass`
- il resume carica i blob `pass_<id>/block_XX.npz`, valida compatibilita
  (layers, D, T_total, blocchi) e continua dal pass successivo.
- `--resume_from_pass 0` seleziona automaticamente la passata massima disponibile.
- il path di resume viene risolto automaticamente se punti a:
  - `<run>/recursive/models`
  - `<run>/recursive`
  - `<run>`

3) Warm-start e generatori per passata
- Pass 1:
  - generatori base (Xi_generator),
  - opzionale warm-start intra-pass da blocco successivo con `--pass1_warm_start_from_next`.
- Pass >= 2:
  - generatori empirici dai boundary samples della passata precedente,
  - warm-start dal blob dello stesso blocco della passata precedente.
- ampiezza jitter generatore empirico controllata da `--empirical_jitter_scale`.

4) Plotting e diagnostica multi-pass
- plot loss/y0 per blocco con una curva per ogni pass:
  - `recursive_blocks_eval_loss.png`
  - `recursive_blocks_eval_y0.png`
- stitched prediction per ogni pass:
  - `recursive_stitched_state_path_passXX.png`
  - `recursive_stitched_Y_pred_passXX.png`
- stitched prediction finale (ultima passata):
  - `recursive_stitched_state_path.png`
  - `recursive_stitched_Y_pred.png`
- plot convergenza Y tra passate:
  - `recursive_stitched_Y_convergence.png`
- per confronto coerente tra passate, il rollout stitched usa input Browniani fissati.

5) Artefatti e salvataggi estesi
- per ogni passata:
  - `pass_XX_logs.csv`
  - `recursive/models/pass_<id>/block_YY.npz`
  - `recursive/models/pass_<id>/block_YY.ckpt` (se attivo `save_tf_checkpoints`)
  - `stitched_predictions_passXX.npz`
- compatibilita mantenuta:
  - se esistono pass1/pass2 vengono salvati anche `pass1_logs.csv` e `pass2_logs.csv`
  - se l'ultima passata e pass2 viene salvato anche `stitched_predictions_pass2.npz`
- summary:
  - `recursive/results.json` contiene `passes`, `resumed_from`, `boundary_stats`
  - campi `pass1` e `pass2` restano presenti se disponibili.


Formato CSV del piano training
------------------------------
Colonne richieste:
- pass_scope
- block_scope
- phase
- n_iter
- lr

Colonne opzionali:
- order (ordinamento interno delle righe)
- enabled (0/1 o true/false)

Valori validi:
- phase:
  - stage
  - final
  - refine
- pass_scope:
  - numero esatto: 1, 2, 3, ...
  - range aperto: 2+ (equivale a >=2)
  - wildcard: all oppure *
- block_scope:
  - terminal
  - other
  - all oppure *
  - blocco specifico: block:<idx> oppure idx:<idx> oppure direttamente <idx>

Priorita matching:
1) scope piu specifico su pass_scope
2) scope piu specifico su block_scope
3) ordinamento per order
4) fallback ai default se nessuna regola matcha

Esempio pronto:
/Users/emanuelelippi/Library/Mobile Documents/com~apple~CloudDocs/Universita/Tirocinio/code/FBSDENN_Lippi/recursive/training_plan_example.csv


Pipeline ricorsiva (dettaglio)
------------------------------

Pass 1 (bootstrap):
- usa generatori di partenza base su tutti i blocchi,
- allena backward dall'ultimo al primo,
- salva blob/checkpoint per ogni blocco.

Pass k >= 2:
- costruisce boundary samples con rollout stitched della passata k-1,
- crea generatori empirici per blocco da quei boundary,
- allena backward con warm-start dai blob della passata k-1,
- salva blob/checkpoint e log della passata k.

Precisione uniforme per blocco:
- reference_loss = loss del blocco terminale della passata corrente,
- blocchi precedenti puntano a reference_loss * (1 + precision_margin),
- se non raggiunta, scattano refine rounds (configurabili via piano/fallback).

Resume:
- se attivo, carica i blob della passata selezionata,
- ricostruisce boundary samples da quei blob,
- continua da pass = loaded_pass + 1 fino a `--passes`.


CLI aggiornata
--------------
Argomenti principali:
- --mode standard|recursive|both
- --M
- --N
- --D
- --T_standard
- --T_total
- --block_size
- --output_dir
- --passes
- --resume_models_dir
- --resume_from_pass
- --empirical_jitter_scale
- --training_plan_csv
- --pass1_warm_start_from_next


Comandi utili
-------------

1) Standard
python3 recursive/recursive1.py --mode standard --T_standard 24 --M 100 --N 100

2) Ricorsivo base (2 pass)
python3 recursive/recursive1.py --mode recursive --T_total 48 --block_size 12 --M 100 --N 100 --passes 2

3) Ricorsivo con 4 pass
python3 recursive/recursive1.py --mode recursive --T_total 48 --block_size 12 --M 100 --N 100 --passes 4

4) Ricorsivo con piano CSV
python3 recursive/recursive1.py --mode recursive --T_total 48 --block_size 12 --M 100 --N 100 --passes 4 --training_plan_csv recursive/training_plan_example.csv

5) Ricorsivo con warm-start tra blocchi nella passata 1
python3 recursive/recursive1.py --mode recursive --T_total 48 --block_size 12 --M 100 --N 100 --passes 4 --pass1_warm_start_from_next

6) Resume da run precedente (continua da pass2 a pass4)
python3 recursive/recursive1.py --mode recursive --T_total 48 --block_size 12 --M 100 --N 100 --passes 4 --resume_models_dir /path/to/run_xxx/recursive/models --resume_from_pass 2

7) Entrambi
python3 recursive/recursive1.py --mode both --T_standard 24 --T_total 48 --block_size 12 --M 100 --N 100 --passes 3


Caricamento modelli in seguito (senza riaddestrare)
----------------------------------------------------
Opzione A: checkpoint TF (.ckpt)
- disponibile per standard e ricorsivo
- metodi:
  - save_model(path)
  - load_model(path)

Opzione B: blob NPZ
- particolarmente utile nel ricorsivo per stitching e analisi offline
- metodi in NN_Quadratic_Coupled_Recursive:
  - save_parameter_blob(path)
  - load_parameter_blob(path, strict=True)

