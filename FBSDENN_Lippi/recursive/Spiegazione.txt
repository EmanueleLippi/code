Spiegazione dettagliata di recursive1.py (versione aggiornata)
==============================================================

File di riferimento
-------------------
/Users/emanuelelippi/Library/Mobile Documents/com~apple~CloudDocs/Universita/Tirocinio/code/FBSDENN_Lippi/recursive/recursive1.py

Questa nota descrive la versione corrente del codice, inclusi:
- salvataggio completo degli artefatti (config, metriche, modelli),
- riduzione dei log su stdout,
- warm-start aggiornato,
- warm-start opzionale tra blocchi nella passata 1,
- piano di training configurabile via CSV.


Obiettivo generale
------------------
Lo script supporta due modalita:
1) standard: training classico su singolo intervallo temporale.
2) recursive: time-stitching a blocchi per orizzonti lunghi (es. T=48).

L'idea del ricorsivo e:
- dividere [0, T_totale] in blocchi [t_i, t_{i+1}],
- allenare backward dall'ultimo blocco al primo,
- usare la rete del blocco successivo come condizione terminale del blocco corrente.


Struttura del codice
--------------------
1) FBSNN (classe madre)
- Mantiene struttura compatibile con la tua base:
  - Xi_generator, placeholders, loss BSDE, Adam, clipping, evaluate/predict.
- Funzioni importanti:
  - save_model(path) / load_model(path) per checkpoint TF (.ckpt).

2) NN_Quadratic_Coupled (prima figlia)
- Mantiene mu_tf, phi_tf, g_tf, sigma_tf della formulazione quadratica 4D.

3) NN_Quadratic_Coupled_Recursive (estensione)
- Aggiunge:
  - tempi assoluti di blocco (t_start, t_end),
  - normalizzazione input tempo/stato,
  - terminal stitching da blob del blocco successivo,
  - export/import pesi in NPZ:
    - export_parameter_blob()
    - import_parameter_blob(...)
    - save_parameter_blob(path)
    - load_parameter_blob(path)


Correzioni e funzionalita aggiunte
----------------------------------

1) Riduzione log che saturavano stdout
- TF_CPP_MIN_LOG_LEVEL=2 impostato a inizio script.
- log_device_placement disattivato di default in FBSNN.
- Effetto: si evita il flood di messaggi tipo replica/gpu device placement.

2) Salvataggio artefatti su disco (non solo stdout)
- Ogni run crea una cartella timestamp:
  output_dir/run_YYYYMMDD_HHMMSS/
- File principali:
  - run_config.json: configurazione completa usata.
  - standard/results.json e recursive/results.json: riassunti finali.
  - CSV con log:
    - standard/stage_logs.csv
    - recursive/pass1_logs.csv
    - recursive/pass2_logs.csv

3) Salvataggio modelli in entrambi i casi
- Standard:
  - checkpoint TF: standard/model.ckpt
  - pesi NPZ: standard/model_weights.npz
- Ricorsivo:
  - per ogni blocco e pass:
    - pass_X/block_YY.npz
    - pass_X/block_YY.ckpt

4) Plot automatici su file
- Standard:
  - standard_eval_loss.png
  - standard_eval_y0.png
- Ricorsivo:
  - recursive_blocks_eval_loss.png
  - recursive_blocks_eval_y0.png
- Se matplotlib non e disponibile:
  - lo script non fallisce, salta i plot e continua.

5) Warm-start attuale (stato corrente)
- Pass 1:
  - di default nessun warm-start da pass precedente.
  - opzionale: se attivi --pass1_warm_start_from_next, il blocco i parte dai pesi del blocco i+1.
- Pass 2:
  - warm-start corretto dallo stesso blocco del Pass 1.
  - cioe blocco b in pass2 parte da pesi di blocco b in pass1.

6) Piano training da CSV
- Nuova opzione CLI:
  --training_plan_csv <file.csv>
- Se non passato, usa i piani default hardcoded.
- Se passato, ogni blocco/passata risolve stage/final/refine dal CSV.


Formato CSV del piano training
------------------------------

Colonne richieste:
- pass_scope
- block_scope
- phase
- n_iter
- lr

Colonne opzionali:
- order (ordinamento interno delle righe)
- enabled (0/1 o true/false)

Valori validi:
- phase:
  - stage
  - final
  - refine
- pass_scope:
  - numero esatto: 1, 2, 3, ...
  - range aperto: 2+ (equivale a >=2)
  - wildcard: all oppure *
- block_scope:
  - terminal
  - other
  - all oppure *
  - blocco specifico: block:<idx> oppure idx:<idx> oppure direttamente <idx>

Priorita matching:
1) scope piu specifico su pass_scope
2) scope piu specifico su block_scope
3) ordinamento per order
4) fallback ai default se nessuna regola matcha

Esempio pronto:
/Users/emanuelelippi/Library/Mobile Documents/com~apple~CloudDocs/Universita/Tirocinio/code/FBSDENN_Lippi/recursive/training_plan_example.csv


Pipeline ricorsiva (dettaglio)
------------------------------

Pass 1 (bootstrap):
- usa generatori di partenza base su tutti i blocchi,
- allena backward dall'ultimo al primo,
- salva NPZ/CKPT per ogni blocco.

Boundary rollout:
- usa i blob pass1 per propagare forward,
- raccoglie campioni di boundary ai tempi t_i.

Pass 2 (refinement):
- costruisce generatori empirici per blocco dai boundary samples,
- allena backward con warm-start dallo stesso blocco del pass1,
- salva di nuovo NPZ/CKPT e log pass2.

Precisione uniforme per blocco:
- reference_loss = loss del blocco terminale,
- blocchi precedenti puntano a reference_loss * (1 + precision_margin),
- se non raggiunta, scattano refine rounds (configurabili via piano/fallback).


CLI aggiornata
--------------

Argomenti principali:
- --mode standard|recursive|both
- --M
- --N
- --D
- --T_standard
- --T_total
- --block_size
- --output_dir
- --training_plan_csv
- --pass1_warm_start_from_next


Comandi utili
-------------

1) Standard
python3 recursive/recursive1.py --mode standard --T_standard 24 --M 100 --N 100

2) Ricorsivo base
python3 recursive/recursive1.py --mode recursive --T_total 48 --block_size 12 --M 100 --N 100

3) Ricorsivo con piano CSV
python3 recursive/recursive1.py --mode recursive --T_total 48 --block_size 12 --M 100 --N 100 --training_plan_csv recursive/training_plan_example.csv

4) Ricorsivo con warm-start tra blocchi nella passata 1
python3 recursive/recursive1.py --mode recursive --T_total 48 --block_size 12 --M 100 --N 100 --pass1_warm_start_from_next

5) Entrambi
python3 recursive/recursive1.py --mode both --T_standard 24 --T_total 48 --block_size 12 --M 100 --N 100


Caricamento modelli in seguito (senza riaddestrare)
----------------------------------------------------

Opzione A: checkpoint TF (.ckpt)
- disponibile per standard e ricorsivo
- metodi:
  - save_model(path)
  - load_model(path)

Opzione B: blob NPZ
- particolarmente utile nel ricorsivo per stitching e analisi offline
- metodi in NN_Quadratic_Coupled_Recursive:
  - save_parameter_blob(path)
  - load_parameter_blob(path, strict=True)
